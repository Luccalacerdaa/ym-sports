name: NotificaÃ§Ãµes de Eventos (CalendÃ¡rio)

on:
  schedule:
    # Verificar eventos a cada 5 minutos
    - cron: '*/5 * * * *'
  
  # Permitir execuÃ§Ã£o manual
  workflow_dispatch:

jobs:
  check-events:
    runs-on: ubuntu-latest
    
    steps:
      - name: Buscar eventos prÃ³ximos (via RPC)
        id: events
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ” BUSCANDO EVENTOS PRÃ“XIMOS"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â° Verificando prÃ³ximos 30 minutos..."
          echo ""
          
          # Buscar eventos usando RPC function (bypass RLS)
          # Usa SERVICE_KEY se disponÃ­vel (acesso total), senÃ£o usa ANON_KEY
          if [ ! -z "${{ secrets.SUPABASE_SERVICE_KEY }}" ]; then
            echo "ğŸ”‘ Usando Service Role Key (acesso total)"
            API_KEY="${{ secrets.SUPABASE_SERVICE_KEY }}"
          else
            echo "ğŸ”‘ Usando Anon Key"
            API_KEY="${{ secrets.SUPABASE_ANON_KEY }}"
          fi
          
          EVENTS=$(curl -s -X POST \
            "${{ secrets.SUPABASE_URL }}/rest/v1/rpc/get_upcoming_events" \
            -H "apikey: $API_KEY" \
            -H "Authorization: Bearer $API_KEY" \
            -H "Content-Type: application/json" \
            -H "Prefer: params=single-object" \
            -d '{"minutes_ahead": 30}')
          
          echo "ğŸ“¦ Resposta do Supabase:"
          echo "$EVENTS" | head -c 500  # Limitar output
          echo ""
          
          # Verificar se houve erro
          if echo "$EVENTS" | grep -q '"message"'; then
            echo "âš ï¸ Erro ao buscar eventos:"
            echo "$EVENTS"
            echo ""
            echo "âŒ Se a funÃ§Ã£o RPC nÃ£o existe, vocÃª precisa executar a migraÃ§Ã£o!"
            echo "ğŸ“– Veja: supabase/migrations/20251218_events_rpc_v3.sql"
            echo ""
            echo "Usando lista vazia como fallback..."
            EVENTS='[]'
            EVENT_COUNT=0
          elif echo "$EVENTS" | grep -q '"code"'; then
            echo "âš ï¸ Erro RPC:"
            echo "$EVENTS"
            echo "Usando lista vazia como fallback..."
            EVENTS='[]'
            EVENT_COUNT=0
          else
            # Extrair eventos do wrapper se necessÃ¡rio
            # Formato antigo: [{"get_upcoming_events": [{...}]}]
            # Formato novo: [{...}]
            if echo "$EVENTS" | grep -q '"get_upcoming_events"'; then
              echo "â„¹ï¸ Detectado formato com wrapper, extraindo eventos..."
              EVENTS=$(echo "$EVENTS" | jq '.[0].get_upcoming_events' 2>/dev/null || echo '[]')
              echo "âœ… Eventos extraÃ­dos do wrapper"
            fi
            
            EVENT_COUNT=$(echo "$EVENTS" | jq '. | length' 2>/dev/null || echo "0")
          fi
          
          echo "events=$EVENTS" >> $GITHUB_OUTPUT
          echo "count=$EVENT_COUNT" >> $GITHUB_OUTPUT
          echo "âœ… Eventos encontrados: $EVENT_COUNT"
          
          # Debug info
          if [ "$EVENT_COUNT" -gt 0 ]; then
            echo ""
            echo "ğŸ“‹ Eventos:"
            echo "$EVENTS" | jq -r '.[] | "  - \(.title) Ã s \(.start_date)"' 2>/dev/null || echo "  (erro ao listar)"
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Enviar notificaÃ§Ãµes de eventos
        if: steps.events.outputs.count > 0
        env:
          EVENTS: ${{ steps.events.outputs.events }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ PROCESSANDO EVENTOS"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          
          SENT_COUNT=0
          
          echo "$EVENTS" | jq -c '.[]' 2>/dev/null | while read event; do
            USER_ID=$(echo "$event" | jq -r '.user_id')
            EVENT_ID=$(echo "$event" | jq -r '.id')
            TITLE=$(echo "$event" | jq -r '.title')
            START_DATE=$(echo "$event" | jq -r '.start_date')
            LOCATION=$(echo "$event" | jq -r '.location // ""')
            
            # Calcular minutos atÃ© o evento
            NOW_EPOCH=$(date +%s)
            EVENT_EPOCH=$(date -d "$START_DATE" +%s)
            MINUTES_UNTIL=$(( ($EVENT_EPOCH - $NOW_EPOCH) / 60 ))
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“… EVENTO: $TITLE"
            echo "â° ComeÃ§a em: $MINUTES_UNTIL minutos"
            echo "ğŸ‘¤ UsuÃ¡rio: ${USER_ID:0:36}"
            echo "ğŸ†” Evento ID: ${EVENT_ID:0:36}"
            
            # Determinar mensagem baseada no tempo
            if [ $MINUTES_UNTIL -le 5 ]; then
              EMOJI="ğŸš¨"
              MESSAGE="Faltam apenas $MINUTES_UNTIL minutos!"
            elif [ $MINUTES_UNTIL -le 15 ]; then
              EMOJI="âš ï¸"
              MESSAGE="ComeÃ§a em $MINUTES_UNTIL minutos"
            else
              EMOJI="ğŸ“…"
              MESSAGE="ComeÃ§a em $MINUTES_UNTIL minutos"
            fi
            
            # Adicionar localizaÃ§Ã£o se existir
            if [ ! -z "$LOCATION" ] && [ "$LOCATION" != "null" ]; then
              MESSAGE="$MESSAGE - Local: $LOCATION"
            fi
            
            FULL_TITLE="$EMOJI $TITLE"
            
            echo "ğŸ“¤ Enviando: $FULL_TITLE"
            echo "ğŸ’¬ Mensagem: $MESSAGE"
            echo ""
            
            # Enviar notificaÃ§Ã£o
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://ym-sports.vercel.app/api/notify \
              -H "Content-Type: application/json" \
              -d "{
                \"user_id\": \"$USER_ID\",
                \"title\": \"$FULL_TITLE\",
                \"body\": \"$MESSAGE\",
                \"url\": \"/dashboard/calendar\"
              }")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)
            
            if [ "$HTTP_CODE" = "200" ]; then
              SENT=$(echo "$BODY" | jq -r '.sent // 0' 2>/dev/null || echo "0")
              FAILED=$(echo "$BODY" | jq -r '.failed // 0' 2>/dev/null || echo "0")
              echo "âœ… HTTP $HTTP_CODE - Enviadas: $SENT, Falharam: $FAILED"
              SENT_COUNT=$((SENT_COUNT + 1))
            else
              echo "âŒ HTTP $HTTP_CODE - Erro ao enviar"
              echo "   Resposta: $BODY"
            fi
            
            echo ""
            sleep 1
          done
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š RESUMO"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… NotificaÃ§Ãµes enviadas: $SENT_COUNT"
          echo "ğŸ‰ Processamento concluÃ­do!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Log resultado
        if: always()
        run: |
          echo "ğŸ“Š Resumo da VerificaÃ§Ã£o:"
          echo "â° HorÃ¡rio UTC: $(date -u '+%Y-%m-%d %H:%M:%S')"
          echo "ğŸŒ HorÃ¡rio BRT: $(TZ=America/Sao_Paulo date '+%Y-%m-%d %H:%M:%S')"
          echo "ğŸ“… Eventos prÃ³ximos: ${{ steps.events.outputs.count }}"
          echo "âœ… VerificaÃ§Ã£o concluÃ­da!"

